#!/usr/bin/env python3
"""
TSDF Fusion - Dense 3D Mesh Generation

This script performs volumetric TSDF (Truncated Signed Distance Function) fusion
to create a dense 3D mesh from depth maps and camera poses generated by SGBM.

Author: Claude Code
Date: 2026-01-25
"""

import numpy as np
import json
import sys
from pathlib import Path
import argparse
from typing import List, Tuple
import time


def check_open3d():
    """Check if Open3D is installed"""
    try:
        import open3d as o3d
        print(f"✓ Open3D {o3d.__version__} detected")
        return True
    except ImportError:
        print("✗ Open3D not found!")
        print("\nPlease install Open3D:")
        print("  pip install open3d")
        print("\nFor CUDA acceleration (optional):")
        print("  pip install open3d-cuda")
        return False


class TSDFFusion:
    """TSDF volumetric fusion for dense 3D reconstruction"""

    def __init__(self, metadata_path: str, voxel_size: float = 0.01,
                 sdf_trunc: float = 0.04, depth_scale: float = 1.0):
        """
        Initialize TSDF fusion

        Args:
            metadata_path: Path to reconstruction metadata JSON
            voxel_size: Size of voxel in meters (smaller = higher resolution, more memory)
            sdf_trunc: Truncation distance for SDF in meters
            depth_scale: Scale factor for depth values (1.0 for meters)
        """
        import open3d as o3d

        self.metadata_path = Path(metadata_path)
        self.voxel_size = voxel_size
        self.sdf_trunc = sdf_trunc
        self.depth_scale = depth_scale

        # Load metadata
        print(f"Loading metadata from {self.metadata_path}...")
        with open(self.metadata_path, 'r') as f:
            self.metadata = json.load(f)

        # Extract camera intrinsics
        cam_params = self.metadata['camera_intrinsics']
        self.width = cam_params['width']
        self.height = cam_params['height']
        self.fx = cam_params['fx']
        self.fy = cam_params['fy']
        self.cx = cam_params['cx']
        self.cy = cam_params['cy']

        # Create Open3D camera intrinsic
        self.intrinsic = o3d.camera.PinholeCameraIntrinsic(
            width=self.width,
            height=self.height,
            fx=self.fx,
            fy=self.fy,
            cx=self.cx,
            cy=self.cy
        )

        # Get keyframes
        self.keyframes = self.metadata['keyframes']
        print(f"✓ Loaded {len(self.keyframes)} keyframes")
        print(f"Camera: {self.width}x{self.height}, fx={self.fx:.2f}, fy={self.fy:.2f}")

        # Initialize TSDF volume
        print(f"\nInitializing TSDF volume...")
        print(f"  Voxel size: {voxel_size*1000:.1f}mm")
        print(f"  SDF truncation: {sdf_trunc*100:.1f}cm")

        self.volume = o3d.pipelines.integration.ScalableTSDFVolume(
            voxel_length=voxel_size,
            sdf_trunc=sdf_trunc,
            color_type=o3d.pipelines.integration.TSDFVolumeColorType.RGB8
        )

        print(f"✓ TSDF volume initialized")

    def quaternion_to_rotation_matrix(self, qx: float, qy: float, qz: float, qw: float) -> np.ndarray:
        """
        Convert quaternion to 3x3 rotation matrix

        Args:
            qx, qy, qz, qw: Quaternion components

        Returns:
            3x3 rotation matrix
        """
        # Normalize quaternion
        norm = np.sqrt(qx*qx + qy*qy + qz*qz + qw*qw)
        qx, qy, qz, qw = qx/norm, qy/norm, qz/norm, qw/norm

        # Convert to rotation matrix
        R = np.array([
            [1 - 2*(qy*qy + qz*qz), 2*(qx*qy - qw*qz), 2*(qx*qz + qw*qy)],
            [2*(qx*qy + qw*qz), 1 - 2*(qx*qx + qz*qz), 2*(qy*qz - qw*qx)],
            [2*(qx*qz - qw*qy), 2*(qy*qz + qw*qx), 1 - 2*(qx*qx + qy*qy)]
        ])

        return R

    def create_pose_matrix(self, tx: float, ty: float, tz: float,
                          qx: float, qy: float, qz: float, qw: float) -> np.ndarray:
        """
        Create 4x4 camera pose matrix from translation and quaternion

        Args:
            tx, ty, tz: Translation components
            qx, qy, qz, qw: Quaternion components

        Returns:
            4x4 camera pose matrix (world-to-camera transformation)
        """
        R = self.quaternion_to_rotation_matrix(qx, qy, qz, qw)
        t = np.array([tx, ty, tz])

        # Create 4x4 transformation matrix
        pose = np.eye(4)
        pose[:3, :3] = R
        pose[:3, 3] = t

        # ORB-SLAM3 gives camera-to-world, but Open3D needs world-to-camera
        # So we need to invert the pose
        pose = np.linalg.inv(pose)

        return pose

    def integrate_depth_map(self, depth_path: str, pose: np.ndarray,
                           color_image_path: str = None) -> bool:
        """
        Integrate a depth map into the TSDF volume

        Args:
            depth_path: Path to depth map (.npy file)
            pose: 4x4 camera pose matrix
            color_image_path: Optional path to color image

        Returns:
            True if integration succeeded
        """
        import open3d as o3d
        import cv2

        # Load depth map
        depth = np.load(depth_path)

        # Check for valid depth
        valid_depth = depth[depth > 0]
        if len(valid_depth) == 0:
            return False

        # Convert depth to Open3D format (uint16, scaled by depth_scale)
        # Open3D expects depth in millimeters for depth_scale=1000
        # Our depth is in meters, so we use depth_scale=1.0
        depth_o3d = o3d.geometry.Image(depth.astype(np.float32))

        # Load or create color image
        if color_image_path and Path(color_image_path).exists():
            color = cv2.imread(color_image_path)
            if color is not None:
                color = cv2.cvtColor(color, cv2.COLOR_BGR2RGB)
                color_o3d = o3d.geometry.Image(color.astype(np.uint8))
            else:
                # Create grayscale color
                color_o3d = o3d.geometry.Image(
                    np.ones((self.height, self.width, 3), dtype=np.uint8) * 128
                )
        else:
            # Create neutral gray color
            color_o3d = o3d.geometry.Image(
                np.ones((self.height, self.width, 3), dtype=np.uint8) * 128
            )

        # Create RGBD image
        rgbd = o3d.geometry.RGBDImage.create_from_color_and_depth(
            color_o3d,
            depth_o3d,
            depth_scale=self.depth_scale,
            depth_trunc=10.0,  # Maximum depth in meters
            convert_rgb_to_intensity=False
        )

        # Integrate into volume
        self.volume.integrate(
            rgbd,
            self.intrinsic,
            pose  # Open3D needs extrinsic (world-to-camera)
        )

        return True

    def run_fusion(self, skip_frames: int = 1, max_frames: int = None,
                  use_color: bool = True, verbose: bool = True) -> bool:
        """
        Run TSDF fusion on all keyframes

        Args:
            skip_frames: Process every Nth frame (1 = all frames)
            max_frames: Maximum number of frames to process (None = all)
            use_color: Whether to use color images
            verbose: Print progress

        Returns:
            True if fusion succeeded
        """
        print("\n" + "=" * 80)
        print("Running TSDF Fusion")
        print("=" * 80)

        total_frames = len(self.keyframes)
        if max_frames:
            total_frames = min(total_frames, max_frames)

        frames_to_process = list(range(0, total_frames, skip_frames))
        num_frames = len(frames_to_process)

        print(f"Processing {num_frames} / {len(self.keyframes)} keyframes (skip={skip_frames})")
        print()

        integrated_count = 0
        failed_count = 0

        start_time = time.time()

        for idx, frame_idx in enumerate(frames_to_process):
            kf = self.keyframes[frame_idx]

            if verbose and idx % 10 == 0:
                elapsed = time.time() - start_time
                rate = idx / elapsed if elapsed > 0 else 0
                eta = (num_frames - idx) / rate if rate > 0 else 0
                print(f"Progress: {idx+1}/{num_frames} ({100*(idx+1)/num_frames:.1f}%) "
                      f"- {rate:.1f} fps - ETA: {eta:.1f}s", end='\r', flush=True)

            # Create pose matrix
            pose = self.create_pose_matrix(
                kf['tx'], kf['ty'], kf['tz'],
                kf['qx'], kf['qy'], kf['qz'], kf['qw']
            )

            # Integrate depth map
            depth_path = kf['depth_map_path']
            color_path = kf['left_image_path'] if use_color else None

            success = self.integrate_depth_map(depth_path, pose, color_path)

            if success:
                integrated_count += 1
            else:
                failed_count += 1

        elapsed = time.time() - start_time

        print()
        print(f"\n✓ TSDF fusion completed in {elapsed:.2f} seconds")
        print(f"  Integrated: {integrated_count} frames")
        print(f"  Failed: {failed_count} frames")
        print(f"  Rate: {integrated_count/elapsed:.2f} fps")

        return integrated_count > 0

    def extract_mesh(self) -> 'open3d.geometry.TriangleMesh':
        """
        Extract triangle mesh from TSDF volume

        Returns:
            Open3D triangle mesh
        """
        import open3d as o3d

        print("\n" + "=" * 80)
        print("Extracting Mesh from TSDF Volume")
        print("=" * 80)

        mesh = self.volume.extract_triangle_mesh()
        mesh.compute_vertex_normals()

        print(f"✓ Mesh extracted")
        print(f"  Vertices: {len(mesh.vertices):,}")
        print(f"  Triangles: {len(mesh.triangles):,}")

        return mesh

    def extract_point_cloud(self) -> 'open3d.geometry.PointCloud':
        """
        Extract point cloud from TSDF volume

        Returns:
            Open3D point cloud
        """
        import open3d as o3d

        print("\n" + "=" * 80)
        print("Extracting Point Cloud from TSDF Volume")
        print("=" * 80)

        pcd = self.volume.extract_point_cloud()

        print(f"✓ Point cloud extracted")
        print(f"  Points: {len(pcd.points):,}")

        return pcd

    def save_mesh(self, mesh: 'open3d.geometry.TriangleMesh',
                 output_path: str, simplify: bool = False,
                 target_triangles: int = 100000):
        """
        Save mesh to file

        Args:
            mesh: Open3D triangle mesh
            output_path: Output file path (.ply, .obj, .stl, etc.)
            simplify: Whether to simplify the mesh
            target_triangles: Target number of triangles for simplification
        """
        import open3d as o3d

        output_path = Path(output_path)

        # Simplify mesh if requested
        if simplify and len(mesh.triangles) > target_triangles:
            print(f"\nSimplifying mesh from {len(mesh.triangles):,} to {target_triangles:,} triangles...")
            mesh = mesh.simplify_quadric_decimation(target_triangles)
            print(f"✓ Simplified: {len(mesh.vertices):,} vertices, {len(mesh.triangles):,} triangles")

        # Save mesh
        print(f"\nSaving mesh to {output_path}...")
        o3d.io.write_triangle_mesh(str(output_path), mesh, write_ascii=False)
        print(f"✓ Mesh saved")

        # Get file size
        size_mb = output_path.stat().st_size / (1024 * 1024)
        print(f"  File size: {size_mb:.2f} MB")

    def save_point_cloud(self, pcd: 'open3d.geometry.PointCloud', output_path: str):
        """
        Save point cloud to file

        Args:
            pcd: Open3D point cloud
            output_path: Output file path (.ply, .pcd, etc.)
        """
        import open3d as o3d

        output_path = Path(output_path)

        print(f"\nSaving point cloud to {output_path}...")
        o3d.io.write_point_cloud(str(output_path), pcd, write_ascii=False)
        print(f"✓ Point cloud saved")

        # Get file size
        size_mb = output_path.stat().st_size / (1024 * 1024)
        print(f"  File size: {size_mb:.2f} MB")


def main():
    parser = argparse.ArgumentParser(
        description="TSDF Fusion - Dense 3D Mesh Generation",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic usage (default settings)
  python tsdf_fusion.py \\
      --input output/dense_reconstruction/dataset_metadata.json \\
      --output output/mesh.ply

  # High-resolution mesh with color
  python tsdf_fusion.py \\
      --input output/dense_reconstruction/dataset_metadata.json \\
      --output output/mesh_hires.ply \\
      --voxel-size 0.005 \\
      --use-color

  # Fast preview (process every 5th frame)
  python tsdf_fusion.py \\
      --input output/dense_reconstruction/dataset_metadata.json \\
      --output output/mesh_preview.ply \\
      --skip 5

  # Simplified mesh for visualization
  python tsdf_fusion.py \\
      --input output/dense_reconstruction/dataset_metadata.json \\
      --output output/mesh_simple.ply \\
      --simplify \\
      --target-triangles 50000
        """
    )

    parser.add_argument('--input', type=str, required=True,
                       help='Path to reconstruction metadata JSON file')
    parser.add_argument('--output', type=str, required=True,
                       help='Output file path for mesh (.ply, .obj, .stl)')
    parser.add_argument('--voxel-size', type=float, default=0.01,
                       help='Voxel size in meters (default: 0.01 = 1cm)')
    parser.add_argument('--sdf-trunc', type=float, default=0.04,
                       help='SDF truncation distance in meters (default: 0.04 = 4cm)')
    parser.add_argument('--skip', type=int, default=1,
                       help='Process every Nth frame (default: 1 = all frames)')
    parser.add_argument('--max-frames', type=int,
                       help='Maximum number of frames to process')
    parser.add_argument('--use-color', action='store_true',
                       help='Use color from images (requires color images)')
    parser.add_argument('--simplify', action='store_true',
                       help='Simplify mesh after extraction')
    parser.add_argument('--target-triangles', type=int, default=100000,
                       help='Target triangle count for simplification (default: 100000)')
    parser.add_argument('--point-cloud', action='store_true',
                       help='Extract point cloud instead of mesh')

    args = parser.parse_args()

    # Check Open3D
    if not check_open3d():
        sys.exit(1)

    # Validate input
    if not Path(args.input).exists():
        print(f"✗ Error: Input file not found: {args.input}")
        sys.exit(1)

    # Create output directory
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    print("\n" + "=" * 80)
    print("TSDF Fusion - Dense 3D Mesh Generation")
    print("=" * 80)
    print(f"Input: {args.input}")
    print(f"Output: {args.output}")
    print(f"Voxel size: {args.voxel_size*1000:.1f}mm")
    print(f"SDF truncation: {args.sdf_trunc*100:.1f}cm")
    if args.skip > 1:
        print(f"Frame skip: {args.skip} (process every {args.skip}th frame)")
    if args.max_frames:
        print(f"Max frames: {args.max_frames}")
    print("=" * 80)
    print()

    try:
        # Initialize TSDF fusion
        fusion = TSDFFusion(
            metadata_path=args.input,
            voxel_size=args.voxel_size,
            sdf_trunc=args.sdf_trunc
        )

        # Run fusion
        success = fusion.run_fusion(
            skip_frames=args.skip,
            max_frames=args.max_frames,
            use_color=args.use_color,
            verbose=True
        )

        if not success:
            print("\n✗ TSDF fusion failed - no frames integrated")
            sys.exit(1)

        # Extract mesh or point cloud
        if args.point_cloud:
            pcd = fusion.extract_point_cloud()
            fusion.save_point_cloud(pcd, args.output)
        else:
            mesh = fusion.extract_mesh()
            fusion.save_mesh(
                mesh,
                args.output,
                simplify=args.simplify,
                target_triangles=args.target_triangles
            )

        print("\n" + "=" * 80)
        print("✓ TSDF Fusion Completed Successfully!")
        print("=" * 80)
        print(f"\nOutput saved to: {args.output}")
        print()
        print("You can visualize the result with:")
        print(f"  python -c \"import open3d as o3d; o3d.visualization.draw_geometries([o3d.io.read_triangle_mesh('{args.output}')])")
        print("=" * 80)

    except KeyboardInterrupt:
        print("\n\n✗ Fusion interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n✗ Error during fusion: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
